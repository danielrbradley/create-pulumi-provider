"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProviderTypes = void 0;
const fs = require("fs");
const ts = require("typescript");
const path = require("path");
const headerWarning = `This file was automatically generated by pulumi-provider-scripts.
DO NOT MODIFY IT BY HAND. Instead, modify the source Pulumi Schema file,
and run "pulumi-provider-scripts gen-provider-types" to regenerate this file.`;
function genTypeProperties(properties, required) {
    if (properties === undefined) {
        return [];
    }
    const requiredLookup = new Set(required);
    return Object.entries(properties).map(([propKey, typeDefinition]) => {
        const type = (() => {
            switch (typeDefinition.type) {
                case "string":
                    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
                case "integer":
                case "number":
                    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
                case "boolean":
                    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
                case "array":
                    return ts.factory.createArrayTypeNode(ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword));
                case "object":
                    return ts.factory.createTypeReferenceNode("Record", [
                        ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                        ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
                    ]);
            }
            return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
        })();
        ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
        return ts.factory.createPropertySignature([ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)], propKey, requiredLookup.has(propKey)
            ? undefined
            : ts.factory.createToken(ts.SyntaxKind.QuestionToken), type);
    });
}
function generateProviderTypes(args) {
    var _a;
    const cwd = args === null || args === void 0 ? void 0 : args.cwd;
    const dir = cwd !== undefined ? path.resolve(cwd) : process.cwd();
    const schemaPath = path.join(dir, "schema.json");
    const schemaText = fs.readFileSync(schemaPath, { encoding: "utf-8" });
    const schema = JSON.parse(schemaText);
    const resources = Object.entries((_a = schema.resources) !== null && _a !== void 0 ? _a : {}).map(([typeToken, resource]) => {
        const tokenParts = typeToken.split(":");
        const typeName = tokenParts[2];
        const inputProperties = genTypeProperties(resource.inputProperties, resource.requiredInputs);
        const inputs = ts.factory.createInterfaceDeclaration(undefined, [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)], typeName + "Inputs", undefined, undefined, inputProperties);
        const outputProperties = genTypeProperties(resource.properties, resource.required);
        const outputs = ts.factory.createInterfaceDeclaration(undefined, [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)], typeName + "Outputs", undefined, undefined, outputProperties);
        return [inputs, outputs];
    });
    const nodes = ts.factory.createNodeArray([
        ts.factory.createJSDocComment(headerWarning),
        ...resources.flat(),
    ]);
    const sourceFile = ts.createSourceFile("provider-types.d.ts", "", ts.ScriptTarget.ES2019, undefined, ts.ScriptKind.TS);
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    const result = printer.printList(ts.ListFormat.MultiLine, nodes, sourceFile);
    const definitionsPath = path.join(dir, "provider-types.d.ts");
    fs.writeFileSync(definitionsPath, result);
}
exports.generateProviderTypes = generateProviderTypes;
//# sourceMappingURL=generate-provider-types.js.map